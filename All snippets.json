[{"copy":0,"tags":["wx","js"],"key":"165e40d57cfcf546562c980bc45cafe83c16a023","createAt":1597287489932,"updateAt":1597287524126,"name":"eventChannel 页面间通信","description":"","files":[{"key":"be2dbbbe6215c49139823e4258447c289b0a2e13","name":"发送页","value":"wx.navigateTo({\n                url: '/pages/shopping/order/item/index',\n                events: {\n                    // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据\n                    acceptDataFromOpenedPage: function (data) {\n                        console.log(data)\n                    },\n                    someEvent: function (data) {\n                        console.log(data)\n                    }\n                },\n                success: function (res) {\n                    // 通过eventChannel向被打开页面传送数据\n                    // 数组格式pro，统一格式\n                    // res.eventChannel.emit('orderItems', {data: 'test'})\n                    res.eventChannel.emit('acceptDataFromOpenerPage', {data: 'test'})\n                }\n            })"},{"key":"85aeeeb2807b5ca78c07e3ae1d0bb27f40e973f8","name":"接受页","value":"  onLoad: function (options) {\n            const eventChannel = this.getOpenerEventChannel()\n            // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据\n            eventChannel.on('orderItems', function (data) {\n                data.orderItems.forEach(item => {\n                    //todo get data from api\n                    console.log(item.productCode)\n                })\n            })\n        },"}]},{"copy":0,"tags":["wx","js"],"key":"25dbe98dc7fc7a67729415ae69446b53eb95a18a","createAt":1597300434284,"updateAt":1597300434284,"name":"page.filter代理page页面","lang":"JavaScript","value":"// utils/filter.js\nfunction loginCheck(pageObj) {\n    //for dev\n    // return pageObj;\n\n    if (pageObj.onLoad) {\n        let _onLoad = pageObj.onLoad;\n        // 使用onLoad的话需要传递options\n        pageObj.onLoad = function (options) {\n            if (wx.getStorageSync('token')) {\n                // 获取当前页面\n                let currentInstance = getPageInstance();\n                _onLoad.call(currentInstance, options);\n\n            } else {\n                //跳转到登录页\n               // getApp().$router.push('user/login/index')\n            }\n        }\n    }\n    return pageObj;\n}\n\n// 获取当前页面\nfunction getPageInstance() {\n    var pages = getCurrentPages();\n    return pages[pages.length - 1];\n}\n\nexports.loginCheck = loginCheck;\n","description":""},{"copy":0,"tags":["js"],"key":"99c9f7c923cf7f895ea44f97378b8129c6b0403c","createAt":1597300584255,"updateAt":1597300584255,"name":"防抖节流","lang":"JavaScript","value":"/*函数节流*/\nfunction throttle(fn, interval) {\n    var enterTime = 0;//触发的时间\n    var gapTime = interval || 300 ;//间隔时间，如果interval不传，则默认300ms\n    return function() {\n        var context = this;\n        var backTime = new Date();//第一次函数return即触发的时间\n        if (backTime - enterTime > gapTime) {\n            fn.call(context,arguments);\n            enterTime = backTime;//赋值给第一次触发的时间，这样就保存了第二次触发的时间\n        }\n    };\n}\n\n/*函数防抖*/\nfunction debounce(fn, interval) {\n    var timer;\n    var gapTime = interval || 1000;//间隔时间，如果interval不传，则默认1000ms\n    return function() {\n        clearTimeout(timer);\n        var context = this;\n        var args = arguments;//保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。\n        timer = setTimeout(function() {\n            fn.call(context,args);\n        }, gapTime);\n    };\n}\n\nexport default {\n    throttle,\n    debounce\n};\n","description":""},{"copy":0,"tags":["js"],"key":"303a2b473e4d16178daba13302d7e1474194b4e2","createAt":1597306238692,"updateAt":1597306259195,"name":"proxy代理拦截","description":"","files":[{"key":"1d11405255a62e9ae508b936460a0b6f61ddeb5b","name":"封装","value":"    proxy(fn) {\n        return new Proxy(fn, {\n            apply(target, ctx, args) {\n\n                console.log(`before:${target.name}`, args)\n                let result = Reflect.apply(...arguments);\n                console.log(`after:${target.name}`, result)\n\n                return result\n            }\n        })\n    },"},{"key":"27dcc053a463734fbc051271f1cc708ee86c4e89","name":"调用","value":" //局部拦截\n    test() {\n        proxy.login(this.sum)()\n    },\n    //整体拦截\n    test: proxy.login(function () {\n        this.add()\n    }),"}]},{"copy":0,"tags":[],"key":"34caa61f682bde4887940f5cd29b86be7d43e981","createAt":1597313447350,"updateAt":1597313447350,"name":"async 并发请求","lang":"JavaScript","value":" let articleList = await article.getList()\n let catalogList = await catalog.getList()\n\n await Promise.all([article.getList(), catalog.getList()])","description":"同步请求与并发请求"},{"copy":0,"tags":["lodash"],"key":"5f2ddedbe392a52f7dae290e8517cc34b06c44d1","createAt":1597321365662,"updateAt":1597321365662,"name":"lodash显式链式调用","lang":"JavaScript","value":"catalogList = _.chain(catalogList)\n            .forEach(o => {\n                o.list = _.filter(articleList, ['catalog_id', o.id])\n                o.head = _.filter(articleList, ['is_col_header', true])\n            })\n            .filter(o => {\n                return o.list.length > 0\n            })\n            .value();","description":""},{"copy":0,"tags":["js"],"key":"cf23b9a2fc24642bb205f1190e854cfb9ba67f6a","createAt":1597375827492,"updateAt":1597376715323,"name":"require/exports 和 import/export ","description":"","files":[{"key":"fd9915d79a73b824b969b18091662a4d4a0e3a11","name":"require/exports","value":"exports.fs = fs\nmodule.exports = fs\n\nconst fs = require('fs')\n"},{"key":"0de3fda70c76370b9dac66f059acbe6b3fea56e1","name":"import/export","value":"export default fs\nexport const fs\nexport function readFile\nexport {readFile, read}\nexport * from 'fs'\n\nimport fs from 'fs'\nimport {default as fs} from 'fs'\nimport * as fs from 'fs'\nimport {readFile} from 'fs'\nimport {readFile as read} from 'fs'\nimport fs, {readFile} from 'fs'\n\n\n//default 写法对比\n// 第一组\nexport default function crc32() {}\nimport crc32 from 'crc32'; \n\n// 第二组\nexport function crc32() {};\nimport {crc32} from 'crc32'; "}]},{"copy":0,"tags":["lodash","wx"],"key":"a1b9d22b0bee152180e2ab6a99798d634f1a801f","createAt":1597393694186,"updateAt":1597393694186,"name":"小程序lodash配置","lang":"JavaScript","value":"//lodash的特殊配置\nObject.assign(global, {\n    Array: Array,\n    Date: Date,\n    Error: Error,\n    Function: Function,\n    Math: Math,\n    Object: Object,\n    RegExp: RegExp,\n    String: String,\n    TypeError: TypeError,\n    setTimeout: setTimeout,\n    clearTimeout: clearTimeout,\n    setInterval: setInterval,\n    clearInterval: clearInterval\n});\n/** 另一种方式\n * 直接引入 lodash modularize 之后的包可以解决\n\n npm install lodash.get\n let get = require('./your_copy_path/lodash.get/index');\n // 直接使用 get(obj, path);\n */","description":"下载lodash.min.js后, 在app.js加上这段代码"},{"copy":0,"tags":["ele","vue"],"key":"3399cb13d65c5215fb3f74eae5696a3f4f1716c0","createAt":1597916405799,"updateAt":1601436389388,"name":"修改UI样式","lang":"SCSS","value":"1.去掉scoped+父类\n1.5 直接找到element的类, 不行再用深度选择,(bug修复?)\n2.使用 /deep/\n  /*\n  修改样式\n  通过使用 box 的class类，找到下面组件内的class类，中间必须得使用 /deep/ 才能找到下面的class类。\n  */\n  // 有时会无效, 那么在element组件外再加一个类选择器即可\n  .box  /deep/ .xxxxx组件样式类 {\n    color: red;\n  }\n3.使用>>>\n\n  /*\n  修改样式\n  通过使用 box的class类，找到下面组件内的class类，中间必须得使用 >>> 才能找到下面的class类。\n  */\n  .box >>> .xxxxx组件样式类 {\n    color: red;\n  }","description":"修改UI样式但不污染全局https://blog.csdn.net/hani_wen/article/details/81545106?utm_source=blogxgwz6"},{"copy":0,"tags":["tpl","ele"],"key":"2fce6a6fd60ed7875534ff8b88df489f2ad49d71","createAt":1598587096106,"updateAt":1598587117193,"name":"列表搜索条件","lang":"HTML","value":"<el-card>\n      <div slot=\"header\">\n        <span>搜索条件</span>\n      </div>\n      <div>\n        <y-form\n          ref=\"articleForm\"\n          :model=\"articleForm\"\n          label-width=\"80px\"\n        >\n          <el-row>\n\n\n          </el-row>\n          <el-row type=\"flex\" align=\"space-between\">\n            <el-col>\n\n              <el-button type=\"primary\" @click=\"onSearch\">查询</el-button>\n              <el-button @click=\"reset\">重置</el-button>\n            </el-col>\n\n            <el-button type=\"success\" @click=\"add\">编写推文</el-button>\n\n          </el-row>\n\n        </y-form>\n\n      </div>\n    </el-card>","description":""},{"copy":0,"tags":[],"key":"d5bf1687cc6912c881799535ce3aa5913d849463","createAt":1598863730602,"updateAt":1598863730602,"name":"yunxiang.json代码生成模板","lang":"JSON","value":",\n  {\n    \"ApiPath\": \"\",\n    \"Discription\": \"商品颜色表\",\n    \"HasCreate\": true,\n    \"HasDelete\": true,\n    \"HasDetail\": true,\n    \"HasEdit\": true,\n    \"HasList\": true,\n    \"ModelNameSingular\": \"color\",\n    \"ModelNamePlural\": \"colors\",\n    \"ModuleNameCn\": \"颜色表\",\n    \"TableName\": \"color\",\n    \"Fields\": [\n      {\n        \"FieldNameCn\": \"颜色选择\",\n        \"Description\": \"\",\n        \"Editable\": true,\n        \"FieldNameEn\": \"code\",\n        \"Searchable\": false,\n        \"SearchCondition\": \"like\",\n\n        \"VueShowinList\": true,\n        \"VueListWidth\": \"\",\n        \"VueListConfig\": \"\",\n        \"VueComponent\": \"y-input\",\n        \"VueComponentConfig\": \"\",\n        \"VueRegx\": \"\",\n        \"VueFormTips\": \"\",\n        \"VueEndMark\": \"标记以便于搜索替换\"\n      }\n    ]\n  }","description":""},{"copy":0,"tags":["js","reg"],"key":"73de062add42e728e7ac6b97329663defcd32110","createAt":1599014419720,"updateAt":1599014447833,"name":"JS正则表达式","lang":"JavaScript","value":"// 提取数字,返回数组\nlet numList = source.match(/[0-9][0-9]*/g)\n\n","description":""},{"copy":0,"tags":["css"],"key":"992f89c0722e39c08434f4d2158d6bd6372b49a2","createAt":1599021408542,"updateAt":1599021408542,"name":"scss循环","lang":"SCSS","value":" /**\n  * 增加商品详情轮播图的介绍\n  * 类选择器+深度选择器+子元素选择器+伪元素+scss数组循环(基1)\n   */\n  $contents: '正面图', '侧面图','背面图';\n  @each $c in $contents {\n    $i: index($contents, $c);\n    .upload-carousels /deep/ .el-upload-list--picture-card .el-upload-list__item:nth-child(#{$i}):before {\n      position: absolute;\n      content: $c;\n    }\n  }","description":"/**\n  * 增加商品详情轮播图的介绍\n  * 类选择器+深度选择器+子元素选择器+伪元素+scss数组循环(基1)\n   */"},{"copy":0,"tags":["vuex","websocket"],"key":"3c94dd11df9a32cb823cc742621e875cf7eb8750","createAt":1599297686856,"updateAt":1599297686856,"name":"vuex结合websocket","lang":"JavaScript","value":"const state = {\n  msg: {},\n  webSocket: {}\n}\n\nconst mutations = {\n  SET_SOCKET: (state, socket) => {\n    state.webSocket = socket\n  },\n  SET_MSG: (state, msg) => {\n    state.msg = msg\n  }\n}\n\nconst actions = {\n  // todo init socket by userinfo\n  init({ commit, state, dispatch }, user) {\n    return new Promise((resolve) => {\n      const ws = new WebSocket('ws://127.0.0.1:8887')\n      commit('SET_SOCKET', ws)\n      dispatch('receive')\n      resolve()\n    })\n  },\n  send({ commit, state }, msg) {\n    return new Promise((resolve) => {\n      const ws = state.webSocket\n      ws.onopen = () => {\n        ws.send(msg)\n        console.log('ws send : ', msg)\n      }\n      resolve()\n    })\n  },\n  receive({ commit, state }) {\n    return new Promise((resolve) => {\n      state.webSocket.onmessage = (evt) => {\n        const msg = evt.data\n        commit('SET_MSG', msg)\n        console.log('ws receive:', msg)\n      }\n      resolve()\n    })\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n\n","description":""},{"copy":0,"tags":["css"],"key":"c3eb673465654509537aa1e24a3210012f1da462","createAt":1599468955893,"updateAt":1599795256175,"name":"隐藏滚动条但是能滚动","lang":"CSS","value":"//多种实现方式\n// 1.  非标准属性, 只在webkit内核生效\n<div class=\"body\" style=\"height: 602px;overflow-x: hidden\"></div>\n\n.body::-webkit-scrollbar {\n  display: none;\n}\n\n//2. 变相隐藏侧边滚动条和底部滚动条, 父容器固定宽度溢出隐藏,子容器宽度为容器+滚动条(17px)并且x轴隐藏, y轴滚动\n// 需要设置子容器的height\n<div class=\"\" style=\"width:375px;overflow: hidden\">\n    <div class=\"body\" style=\"height: 100%; width:392px;overflow-x: hidden;overflow-y: scroll\">\n        content\n    </div>\n</div>\n","description":""},{"copy":0,"tags":["vuex"],"key":"bdda2eca48289a43ed6596b1bf5c1f0ae0efebef","createAt":1600156843976,"updateAt":1600156843976,"name":"解决vuex F5刷新消失的问题","lang":"JavaScript","value":"1.vuex-persistedstate\nhttps://www.cnblogs.com/lemoncool/p/9645587.html \n\n2. 刷新时手动存到strage\n created () {\n    //在页面加载时读取sessionStorage里的状态信息\n    if (sessionStorage.getItem(\"store\") ) {\n      this.$store.replaceState(Object.assign({}, this.$store.state,JSON.parse(sessionStorage.getItem(\"store\"))));\n      sessionStorage.removeItem('store');\n    }\n \n    //在页面刷新时将vuex里的信息保存到sessionStorage里\n    window.addEventListener(\"beforeunload\",()=>{\n      sessionStorage.setItem(\"store\",JSON.stringify(this.$store.state))\n    })\n  }\n\n3. 经过路由的导航守卫没有数据时重新请求(element admin 的方法)\n","description":""},{"copy":0,"tags":["架构"],"key":"e13555be12c6c86e2fbb9d9f4402222b93abee38","createAt":1600158639854,"updateAt":1600158639854,"name":"vue cli3配置","lang":"JavaScript","value":"1. https://juejin.im/post/6844903775950356488","description":"vue.config.js"},{"copy":0,"tags":["css"],"key":"a5f5699c17aaffd6fdb54fc0eedb56be5705062d","createAt":1600422364280,"updateAt":1600422402332,"name":"修改element样式的几种方式","lang":"CSS","value":"1. 简单粗暴: 删除scope , 缺点全局污染, 不推荐\n2. 找到element的类后, 增加深度选择器/deep/, (>>>也说可以, 但是我测试不生效)\n/deep/ .el-upload-dragger \n3. 修改子组件的element样式, 要先找到子组件中声明的类,再找到element的类\n.y-radio /deep/ .el-radio {  }\n\n","description":""},{"copy":0,"tags":["js","reduce"],"key":"67adf3a7e3b6b4d9db5791bbe4cd3c018afc0690","createAt":1600688126204,"updateAt":1600688126204,"name":"经纬度+reduce","lang":"JavaScript","value":"// 经纬度数据预处理，一维经纬度混合数组 转 经纬度对象数组\nconst arr = [112.91752281707764, 22.986407734375, 112.99305382293701, 22.9809145703125, 112.92026939910889, 22.961001850585937, 112.91752281707764, 22.986407734375]\n// reducer 函数接收4个参数:累计器,当前值,当前索引,源数组\narr.reduce((a, b, idx) => {\n  if (idx % 2) { // 如果是奇数项\n    const number = Math.ceil(idx / 2) - 1\n    // const number = a.length - 1\n    a[number].lat = b // 设置纬度\n    return a // 返回下一次迭代的累加器\n  } else { // 如果是偶数项\n    // 添加经度，返回合并后的数组  作为下一次迭代的累加器\n    return [...a, { lng: b }]\n  }\n}, []// 累加器初始化\n)","description":""},{"copy":0,"tags":["js"],"key":"bc2a8e21143f674e5740048287602b9b1906dcb8","createAt":1600688544243,"updateAt":1600688544243,"name":"遍历对象的方法","lang":"JavaScript","value":"1. for in  循环遍历对象自身的和继承的可枚举属性\n2. Object.keys 返回对象自身可枚举属性组成的数组\n3. Object.values 返回一个给定对象自身的所有可枚举属性[值]的数组\n\nps:Object.getOwnPropertyNames获取不可枚举属性\n","description":""},{"copy":0,"tags":["ele"],"key":"85c70ccadd5c15c9f47d85a826b677eb263bd2f3","createAt":1601286263337,"updateAt":1601286263337,"name":"ele选择器自定义过滤函数","lang":"JavaScript","value":"// 注释和非注释是两种方法(各有bug, 非注释的bug是value = 实际输入值) \nfilterBrand(e) {\n      // this.brandOptions = this._.filter(this.brandOptionsSrc, (item) => {\n      //   // eslint-disable-next-line eqeqeq\n      //   const contain = item.value.indexOf(e) !== -1 || item.label.indexOf(e) !== -1\n      //   if (contain) {\n      //     return item\n      //     // this.$set(this.brandOptions, this.brandOptions.length, item)\n      //   }\n      // })\n      this.goodForm.brand = e\n      if (e) { // val存在\n        this.brandOptions = this.brandOptionsSrc.filter((item) => item.value.indexOf(e) !== -1 || item.label.indexOf(e) !== -1)\n      } else { // val为空时，还原数组\n        this.brandOptions = this.brandOptionsSrc\n      }\n    },\n    // initBrandOptions() {\n    //   this.brandOptionsSrc.map((item, idx) => {\n    //     this.$set(this.brandOptions, idx, item)\n    //   })\n    // }","description":""},{"copy":0,"tags":["wx","js"],"key":"165e40d57cfcf546562c980bc45cafe83c16a023","createAt":1597287489932,"updateAt":1597287524126,"name":"eventChannel 页面间通信","description":"","files":[{"key":"be2dbbbe6215c49139823e4258447c289b0a2e13","name":"发送页","value":"wx.navigateTo({\n                url: '/pages/shopping/order/item/index',\n                events: {\n                    // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据\n                    acceptDataFromOpenedPage: function (data) {\n                        console.log(data)\n                    },\n                    someEvent: function (data) {\n                        console.log(data)\n                    }\n                },\n                success: function (res) {\n                    // 通过eventChannel向被打开页面传送数据\n                    // 数组格式pro，统一格式\n                    // res.eventChannel.emit('orderItems', {data: 'test'})\n                    res.eventChannel.emit('acceptDataFromOpenerPage', {data: 'test'})\n                }\n            })"},{"key":"85aeeeb2807b5ca78c07e3ae1d0bb27f40e973f8","name":"接受页","value":"  onLoad: function (options) {\n            const eventChannel = this.getOpenerEventChannel()\n            // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据\n            eventChannel.on('orderItems', function (data) {\n                data.orderItems.forEach(item => {\n                    //todo get data from api\n                    console.log(item.productCode)\n                })\n            })\n        },"}]},{"copy":0,"tags":["wx","js"],"key":"25dbe98dc7fc7a67729415ae69446b53eb95a18a","createAt":1597300434284,"updateAt":1597300434284,"name":"page.filter代理page页面","lang":"JavaScript","value":"// utils/filter.js\nfunction loginCheck(pageObj) {\n    //for dev\n    // return pageObj;\n\n    if (pageObj.onLoad) {\n        let _onLoad = pageObj.onLoad;\n        // 使用onLoad的话需要传递options\n        pageObj.onLoad = function (options) {\n            if (wx.getStorageSync('token')) {\n                // 获取当前页面\n                let currentInstance = getPageInstance();\n                _onLoad.call(currentInstance, options);\n\n            } else {\n                //跳转到登录页\n               // getApp().$router.push('user/login/index')\n            }\n        }\n    }\n    return pageObj;\n}\n\n// 获取当前页面\nfunction getPageInstance() {\n    var pages = getCurrentPages();\n    return pages[pages.length - 1];\n}\n\nexports.loginCheck = loginCheck;\n","description":""},{"copy":0,"tags":["js"],"key":"99c9f7c923cf7f895ea44f97378b8129c6b0403c","createAt":1597300584255,"updateAt":1597300584255,"name":"防抖节流","lang":"JavaScript","value":"/*函数节流*/\nfunction throttle(fn, interval) {\n    var enterTime = 0;//触发的时间\n    var gapTime = interval || 300 ;//间隔时间，如果interval不传，则默认300ms\n    return function() {\n        var context = this;\n        var backTime = new Date();//第一次函数return即触发的时间\n        if (backTime - enterTime > gapTime) {\n            fn.call(context,arguments);\n            enterTime = backTime;//赋值给第一次触发的时间，这样就保存了第二次触发的时间\n        }\n    };\n}\n\n/*函数防抖*/\nfunction debounce(fn, interval) {\n    var timer;\n    var gapTime = interval || 1000;//间隔时间，如果interval不传，则默认1000ms\n    return function() {\n        clearTimeout(timer);\n        var context = this;\n        var args = arguments;//保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。\n        timer = setTimeout(function() {\n            fn.call(context,args);\n        }, gapTime);\n    };\n}\n\nexport default {\n    throttle,\n    debounce\n};\n","description":""},{"copy":0,"tags":["js"],"key":"303a2b473e4d16178daba13302d7e1474194b4e2","createAt":1597306238692,"updateAt":1597306259195,"name":"proxy代理拦截","description":"","files":[{"key":"1d11405255a62e9ae508b936460a0b6f61ddeb5b","name":"封装","value":"    proxy(fn) {\n        return new Proxy(fn, {\n            apply(target, ctx, args) {\n\n                console.log(`before:${target.name}`, args)\n                let result = Reflect.apply(...arguments);\n                console.log(`after:${target.name}`, result)\n\n                return result\n            }\n        })\n    },"},{"key":"27dcc053a463734fbc051271f1cc708ee86c4e89","name":"调用","value":" //局部拦截\n    test() {\n        proxy.login(this.sum)()\n    },\n    //整体拦截\n    test: proxy.login(function () {\n        this.add()\n    }),"}]},{"copy":0,"tags":[],"key":"34caa61f682bde4887940f5cd29b86be7d43e981","createAt":1597313447350,"updateAt":1597313447350,"name":"async 并发请求","lang":"JavaScript","value":" let articleList = await article.getList()\n let catalogList = await catalog.getList()\n\n await Promise.all([article.getList(), catalog.getList()])","description":"同步请求与并发请求"},{"copy":0,"tags":["lodash"],"key":"5f2ddedbe392a52f7dae290e8517cc34b06c44d1","createAt":1597321365662,"updateAt":1597321365662,"name":"lodash显式链式调用","lang":"JavaScript","value":"catalogList = _.chain(catalogList)\n            .forEach(o => {\n                o.list = _.filter(articleList, ['catalog_id', o.id])\n                o.head = _.filter(articleList, ['is_col_header', true])\n            })\n            .filter(o => {\n                return o.list.length > 0\n            })\n            .value();","description":""},{"copy":0,"tags":["js"],"key":"cf23b9a2fc24642bb205f1190e854cfb9ba67f6a","createAt":1597375827492,"updateAt":1597376715323,"name":"require/exports 和 import/export ","description":"","files":[{"key":"fd9915d79a73b824b969b18091662a4d4a0e3a11","name":"require/exports","value":"exports.fs = fs\nmodule.exports = fs\n\nconst fs = require('fs')\n"},{"key":"0de3fda70c76370b9dac66f059acbe6b3fea56e1","name":"import/export","value":"export default fs\nexport const fs\nexport function readFile\nexport {readFile, read}\nexport * from 'fs'\n\nimport fs from 'fs'\nimport {default as fs} from 'fs'\nimport * as fs from 'fs'\nimport {readFile} from 'fs'\nimport {readFile as read} from 'fs'\nimport fs, {readFile} from 'fs'\n\n\n//default 写法对比\n// 第一组\nexport default function crc32() {}\nimport crc32 from 'crc32'; \n\n// 第二组\nexport function crc32() {};\nimport {crc32} from 'crc32'; "}]},{"copy":0,"tags":["lodash","wx"],"key":"a1b9d22b0bee152180e2ab6a99798d634f1a801f","createAt":1597393694186,"updateAt":1597393694186,"name":"小程序lodash配置","lang":"JavaScript","value":"//lodash的特殊配置\nObject.assign(global, {\n    Array: Array,\n    Date: Date,\n    Error: Error,\n    Function: Function,\n    Math: Math,\n    Object: Object,\n    RegExp: RegExp,\n    String: String,\n    TypeError: TypeError,\n    setTimeout: setTimeout,\n    clearTimeout: clearTimeout,\n    setInterval: setInterval,\n    clearInterval: clearInterval\n});\n/** 另一种方式\n * 直接引入 lodash modularize 之后的包可以解决\n\n npm install lodash.get\n let get = require('./your_copy_path/lodash.get/index');\n // 直接使用 get(obj, path);\n */","description":"下载lodash.min.js后, 在app.js加上这段代码"},{"copy":0,"tags":["ele","vue"],"key":"3399cb13d65c5215fb3f74eae5696a3f4f1716c0","createAt":1597916405799,"updateAt":1597916405799,"name":"修改UI样式","lang":"SCSS","value":"1.去掉scoped+父类\n2.使用 /deep/\n  /*\n  修改样式\n  通过使用 box 的class类，找到下面组件内的class类，中间必须得使用 /deep/ 才能找到下面的class类。\n  */\n  .box  /deep/ .xxxxx组件样式类 {\n    color: red;\n  }\n3.使用>>>\n\n  /*\n  修改样式\n  通过使用 box的class类，找到下面组件内的class类，中间必须得使用 >>> 才能找到下面的class类。\n  */\n  .box >>> .xxxxx组件样式类 {\n    color: red;\n  }","description":"修改UI样式但不污染全局https://blog.csdn.net/hani_wen/article/details/81545106?utm_source=blogxgwz6"},{"copy":0,"tags":["tpl","ele"],"key":"2fce6a6fd60ed7875534ff8b88df489f2ad49d71","createAt":1598587096106,"updateAt":1598587117193,"name":"列表搜索条件","lang":"HTML","value":"<el-card>\n      <div slot=\"header\">\n        <span>搜索条件</span>\n      </div>\n      <div>\n        <y-form\n          ref=\"articleForm\"\n          :model=\"articleForm\"\n          label-width=\"80px\"\n        >\n          <el-row>\n\n\n          </el-row>\n          <el-row type=\"flex\" align=\"space-between\">\n            <el-col>\n\n              <el-button type=\"primary\" @click=\"onSearch\">查询</el-button>\n              <el-button @click=\"reset\">重置</el-button>\n            </el-col>\n\n            <el-button type=\"success\" @click=\"add\">编写推文</el-button>\n\n          </el-row>\n\n        </y-form>\n\n      </div>\n    </el-card>","description":""},{"copy":0,"tags":[],"key":"d5bf1687cc6912c881799535ce3aa5913d849463","createAt":1598863730602,"updateAt":1598863730602,"name":"yunxiang.json代码生成模板","lang":"JSON","value":",\n  {\n    \"ApiPath\": \"\",\n    \"Discription\": \"商品颜色表\",\n    \"HasCreate\": true,\n    \"HasDelete\": true,\n    \"HasDetail\": true,\n    \"HasEdit\": true,\n    \"HasList\": true,\n    \"ModelNameSingular\": \"color\",\n    \"ModelNamePlural\": \"colors\",\n    \"ModuleNameCn\": \"颜色表\",\n    \"TableName\": \"color\",\n    \"Fields\": [\n      {\n        \"FieldNameCn\": \"颜色选择\",\n        \"Description\": \"\",\n        \"Editable\": true,\n        \"FieldNameEn\": \"code\",\n        \"Searchable\": false,\n        \"SearchCondition\": \"like\",\n\n        \"VueShowinList\": true,\n        \"VueListWidth\": \"\",\n        \"VueListConfig\": \"\",\n        \"VueComponent\": \"y-input\",\n        \"VueComponentConfig\": \"\",\n        \"VueRegx\": \"\",\n        \"VueFormTips\": \"\",\n        \"VueEndMark\": \"标记以便于搜索替换\"\n      }\n    ]\n  }","description":""},{"copy":0,"tags":["js","reg"],"key":"73de062add42e728e7ac6b97329663defcd32110","createAt":1599014419720,"updateAt":1599014447833,"name":"JS正则表达式","lang":"JavaScript","value":"// 提取数字,返回数组\nlet numList = source.match(/[0-9][0-9]*/g)\n\n","description":""},{"copy":0,"tags":["css"],"key":"992f89c0722e39c08434f4d2158d6bd6372b49a2","createAt":1599021408542,"updateAt":1599021408542,"name":"scss循环","lang":"SCSS","value":" /**\n  * 增加商品详情轮播图的介绍\n  * 类选择器+深度选择器+子元素选择器+伪元素+scss数组循环(基1)\n   */\n  $contents: '正面图', '侧面图','背面图';\n  @each $c in $contents {\n    $i: index($contents, $c);\n    .upload-carousels /deep/ .el-upload-list--picture-card .el-upload-list__item:nth-child(#{$i}):before {\n      position: absolute;\n      content: $c;\n    }\n  }","description":"/**\n  * 增加商品详情轮播图的介绍\n  * 类选择器+深度选择器+子元素选择器+伪元素+scss数组循环(基1)\n   */"},{"copy":0,"tags":["vuex","websocket"],"key":"3c94dd11df9a32cb823cc742621e875cf7eb8750","createAt":1599297686856,"updateAt":1599297686856,"name":"vuex结合websocket","lang":"JavaScript","value":"const state = {\n  msg: {},\n  webSocket: {}\n}\n\nconst mutations = {\n  SET_SOCKET: (state, socket) => {\n    state.webSocket = socket\n  },\n  SET_MSG: (state, msg) => {\n    state.msg = msg\n  }\n}\n\nconst actions = {\n  // todo init socket by userinfo\n  init({ commit, state, dispatch }, user) {\n    return new Promise((resolve) => {\n      const ws = new WebSocket('ws://127.0.0.1:8887')\n      commit('SET_SOCKET', ws)\n      dispatch('receive')\n      resolve()\n    })\n  },\n  send({ commit, state }, msg) {\n    return new Promise((resolve) => {\n      const ws = state.webSocket\n      ws.onopen = () => {\n        ws.send(msg)\n        console.log('ws send : ', msg)\n      }\n      resolve()\n    })\n  },\n  receive({ commit, state }) {\n    return new Promise((resolve) => {\n      state.webSocket.onmessage = (evt) => {\n        const msg = evt.data\n        commit('SET_MSG', msg)\n        console.log('ws receive:', msg)\n      }\n      resolve()\n    })\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n\n","description":""},{"copy":0,"tags":["css"],"key":"c3eb673465654509537aa1e24a3210012f1da462","createAt":1599468955893,"updateAt":1599795256175,"name":"隐藏滚动条但是能滚动","lang":"CSS","value":"//多种实现方式\n// 1.  非标准属性, 只在webkit内核生效\n<div class=\"body\" style=\"height: 602px;overflow-x: hidden\"></div>\n\n.body::-webkit-scrollbar {\n  display: none;\n}\n\n//2. 变相隐藏侧边滚动条和底部滚动条, 父容器固定宽度溢出隐藏,子容器宽度为容器+滚动条(17px)并且x轴隐藏, y轴滚动\n// 需要设置子容器的height\n<div class=\"\" style=\"width:375px;overflow: hidden\">\n    <div class=\"body\" style=\"height: 100%; width:392px;overflow-x: hidden;overflow-y: scroll\">\n        content\n    </div>\n</div>\n","description":""},{"copy":1,"tags":["vuex"],"key":"bdda2eca48289a43ed6596b1bf5c1f0ae0efebef","createAt":1600156843976,"updateAt":1600576680527,"name":"解决vuex F5刷新消失的问题","lang":"JavaScript","value":"1.vuex-persistedstate\nhttps://www.cnblogs.com/lemoncool/p/9645587.html \n\n2. 刷新时手动存到strage\n created () {\n    //在页面加载时读取sessionStorage里的状态信息\n    if (sessionStorage.getItem(\"store\") ) {\n      this.$store.replaceState(Object.assign({}, this.$store.state,JSON.parse(sessionStorage.getItem(\"store\"))));\n      sessionStorage.removeItem('store');\n    }\n \n    //在页面刷新时将vuex里的信息保存到sessionStorage里\n    window.addEventListener(\"beforeunload\",()=>{\n      sessionStorage.setItem(\"store\",JSON.stringify(this.$store.state))\n    })\n  }\n\n3. 经过路由的导航守卫没有数据时重新请求(element admin 的方法)\n","description":""},{"copy":0,"tags":["config"],"key":"c4184e29e8135a96386ece66d7ec967fd30963ad","createAt":1600922219388,"updateAt":1600922257463,"name":"vue cli3 配置文件","description":"https://blog.csdn.net/weixin_37615202/article/details/90079921","files":[{"key":"8c0533118c5855b867076819e333dd47027efd7d","name":"vue.config.js","value":"const path = require(\"path\");\nconst resolve = dir => path.join(__dirname, dir);\n//用于生产环境去除多余的css\nconst PurgecssPlugin = require(\"purgecss-webpack-plugin\");\n//全局文件路径\nconst glob = require(\"glob-all\");\n//压缩代码并去掉console\nconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\");\n//代码打包zip\nconst CompressionWebpackPlugin = require(\"compression-webpack-plugin\");\nconst productionGzipExtensions = /\\.(js|css|json|txt|html|ico|svg)(\\?.*)?$/i;\nmodule.exports = {\n  // 废弃baseUrl  一般运维会配置好的\n  publicPath: process.env.NODE_ENV === \"production\" ? \"/configtest/\" : \"/\",\n  //打包的输出目录\n  outputDir: \"dist/configtest\",\n  //保存是校验\n  lintOnSave: true,\n  //如果文件等设置\n  pages: {\n    index: {\n      entry: \"src/main.js\",\n      template: \"public/index.html\",\n      filename: \"index.html\"\n    }\n  },\n  //静态资源打包路径\n  assetsDir: \"static\",\n  //默认false 可以加快打包\n  productionSourceMap: false,\n  //打包后的启动文件\n  indexPath: \"congfigtest.html\",\n  //打包文件是否使用hash\n  filenameHashing: true,\n  runtimeCompiler: false,\n  transpileDependencies: [],\n  //打包的css路径及命名\n  css: {\n    modules: false,\n    //vue 文件中修改css 不生效 注释掉  extract:true\n    extract: {\n      filename: \"style/[name].[hash:8].css\",\n      chunkFilename: \"style/[name].[hash:8].css\"\n    },\n    sourceMap: false,\n    loaderOptions: {\n      css: {},\n      less: {\n        // 向全局less样式传入共享的全局变量\n        // data: `@import \"~assets/less/variables.less\";$src: \"${process.env.VUE_APP_SRC}\";`\n      },\n      // postcss 设置\n      postcss: {\n        plugins: [\n          require(\"postcss-px-to-viewport\")({\n            viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750\n            viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置\n            unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）\n            viewportUnit: \"vw\", // 指定需要转换成的视窗单位，建议使用vw\n            selectorBlackList: [\".ignore\", \".hairlines\"], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名\n            minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值\n            mediaQuery: false // 允许在媒体查询中转换`px`\n          })\n        ]\n      }\n    }\n  },\n  //webpack 链式配置   默认已经配置好了  node_moudles/@vue\n  chainWebpack: config => {\n    // 修复HMR\n    config.resolve.symlinks(true);\n    // 修复Lazy loading routes  按需加载的问题，如果没有配置按需加载不需要写，会报错\n    // config.plugin(\"html\").tap(args => {\n    //   args[0].chunksSortMode = \"none\";\n    //   return args;\n    // });\n    //添加别名\n    config.resolve.alias\n      .set(\"@\", resolve(\"src\"))\n      .set(\"assets\", resolve(\"src/assets\"))\n      .set(\"components\", resolve(\"src/components\"))\n      .set(\"layout\", resolve(\"src/layout\"))\n      .set(\"base\", resolve(\"src/base\"))\n      .set(\"static\", resolve(\"src/static\"));\n    // 压缩图片\n    config.module\n      .rule(\"images\")\n      .use(\"image-webpack-loader\")\n      .loader(\"image-webpack-loader\")\n      .options({\n        mozjpeg: { progressive: true, quality: 65 },\n        optipng: { enabled: false },\n        pngquant: { quality: \"65-90\", speed: 4 },\n        gifsicle: { interlaced: false },\n        webp: { quality: 75 }\n      });\n  },\n  //webpack 配置\n  configureWebpack: config => {\n    const plugins = [];\n    //去掉不用的css 多余的css\n    plugins.push(\n      new PurgecssPlugin({\n        paths: glob.sync([path.join(__dirname, \"./**/*.vue\")]),\n        extractors: [\n          {\n            extractor: class Extractor {\n              static extract(content) {\n                const validSection = content.replace(\n                  /<style([\\s\\S]*?)<\\/style>+/gim,\n                  \"\"\n                );\n                return validSection.match(/[A-Za-z0-9-_:/]+/g) || [];\n              }\n            },\n            extensions: [\"html\", \"vue\"]\n          }\n        ],\n        whitelist: [\"html\", \"body\"],\n        whitelistPatterns: [/el-.*/],\n        whitelistPatternsChildren: [/^token/, /^pre/, /^code/]\n      })\n    );\n    //启用代码压缩\n    plugins.push(\n      new UglifyJsPlugin({\n        uglifyOptions: {\n          compress: {\n            warnings: false,\n            drop_console: true,\n            drop_debugger: false,\n            pure_funcs: [\"console.log\"] //移除console\n          }\n        },\n        sourceMap: false,\n        parallel: true\n      })\n    ),\n      //代码压缩打包\n      plugins.push(\n        new CompressionWebpackPlugin({\n          filename: \"[path].gz[query]\",\n          algorithm: \"gzip\",\n          test: productionGzipExtensions,\n          threshold: 10240,\n          minRatio: 0.8\n        })\n      );\n    config.plugins = [...config.plugins, ...plugins];\n  },\n  parallel: require(\"os\").cpus().length > 1,\n  pluginOptions: {},\n  pwa: {},\n  //设置代理\n  devServer: {\n    port: 8080,\n    host: \"0.0.0.0\",\n    https: false,\n    open: true,\n    openPage: \"about\",\n    hot: true,\n    disableHostCheck: true,\n    proxy: {\n      \"/api\": {\n        target: \"https://cdn.awenliang.cn\",\n        ws: true,\n        changeOrigin: true\n      },\n      \"/foo\": {\n        target: \"https://cdn.awenliang.cn\",\n        ws: true,\n        changeOrigin: true\n      }\n    }\n  }\n};"},{"key":"e33d70323fb4ccfe5e505c171a8b4a6a0fc7af69","name":"babel.config.js","value":"//npm i --save-dev babel-plugin-transform-remove-console\nconst plugins = [];\n// if(['production', 'prod'].includes(process.env.NODE_ENV)) {\n//   plugins.push(\"transform-remove-console\")\n// }\n \nmodule.exports = {\n  presets: [[\"@vue/app\", { useBuiltIns: \"entry\" }]],\n  plugins: plugins\n};"},{"key":"aa5c5f4900013e68ca81bc47e78a51653672eb3e","name":"postcss.config.js","value":"const autoprefixer = require(\"autoprefixer\");\nlet plugins = [];\nmodule.exports = {\n  plugins: [...plugins, autoprefixer]\n};"}]},{"copy":0,"tags":["vue"],"key":"81d22c6eae19d63a56154c5b1e59c715ac68e8e3","createAt":1602158803689,"updateAt":1602158803689,"name":"解决多事件绑定重复调用问题","lang":"JavaScript","value":"@keyup.enter.native=\"$event.target.blur\" \n@blur=\"submit\" ","description":"解决键盘和blue绑定同一事件重复触发的问题@keyup.enter.native=\"$event.target.blur\" @blur=\"submit\" "},{"copy":0,"tags":["vue"],"key":"3b41404a3916612829ff590b998980d009226f81","createAt":1602159064566,"updateAt":1602159064566,"name":"this.$nextTick","lang":"JavaScript","value":"","description":"将回调延迟到下次 DOM 更新循环之后执行。 因为DOM更新是异步的"},{"copy":0,"tags":["Array"],"key":"d3cdc081acad932698d5a9aa074afe0ca6840380","createAt":1602681106524,"updateAt":1602681106524,"name":"Array常用方法","description":"","files":[{"key":"5513a445e40239af7419f0a3f443691f1b24f0e1","name":"生成指定长度的数组","value":"let a = [...new Array(100).keys()] // [0,1,...., 99] 0-99\n\nlet c = new Array(100).fill('')  // 100个空数组"}]},{"key":"fa558464651ca213c452f9d01c793a586a1720f7","createAt":1604574169001,"updateAt":1604574169001,"copy":0,"tags":["vue"],"name":"Vue使用装饰器eg: 防抖节流, log , loading,  确认框","lang":"JavaScript","value":"\n作为一个曾经的Java coder, 当我第一次看到js里面的装饰器(Decorator)的时候，就马上想到了Java中的注解，当然在实际原理和功能上面，Java的注解和js的装饰器还是有很大差别的。本文题目是Vue中使用装饰器，我是认真的，但本文将从装饰器的概念开发聊起，一起来看看吧。\n\n通过本文内容，你将学到以下内容:\n\n了解什么是装饰器\n\n在方法使用装饰器\n\n在class中使用装饰器\n\n在Vue中使用装饰器\n\n❝\n本文首发于公众号【前端有的玩】，不想当咸鱼，想要换工作，关注公众号，带你每日一起刷大厂面试题，关注 === 大厂offer。\n\n❞\n什么是装饰器\n装饰器是ES2016提出来的一个提案，当前处于Stage 2阶段，关于装饰器的体验，可以点击 https://github.com/tc39/proposal-decorators查看详情。装饰器是一种与类相关的语法糖，用来包装或者修改类或者类的方法的行为，其实装饰器就是设计模式中装饰者模式的一种实现方式。不过前面说的这些概念太干了，我们用人话来翻译一下，举一个例子。\n\n在日常开发写bug过程中，我们经常会用到防抖和节流，比如像下面这样\n\nclass MyClass {\n  follow = debounce(function() {\n    console.log('我是子君，关注我哦')\n  }, 100)\n}\n \nconst myClass = new MyClass()\n// 多次调用只会输出一次\nmyClass.follow()\nmyClass.follow()\n上面是一个防抖的例子，我们通过debounce函数将另一个函数包起来，实现了防抖的功能，这时候再有另一个需求，比如希望在调用follow函数前后各打印一段日志，这时候我们还可以再开发一个log函数，然后继续将follow包装起来\n\n/**\n * 最外层是防抖，否则log会被调用多次\n */\nclass MyClass {\n  follow = debounce(\n    log(function() {\n      console.log('我是子君，关注我哦')\n    }),\n    100\n  )\n}\n上面代码中的debounce和log两个函数，本质上是两个包装函数，通过这两个函数对原函数的包装，使原函数的行为发生了变化，而js中的装饰器的原理就是这样的，我们使用装饰器对上面的代码进行改造\n\nclass MyClass {\n  @debounce(100)\n  @log\n  follow() {\n    console.log('我是子君，关注我哦')\n  }\n}\n装饰器的形式就是 @ + 函数名，如果有参数的话，后面的括号里面可以传参\n\n在方法上使用装饰器\n装饰器可以应用到class上或者class里面的属性上面，但一般情况下，应用到class属性上面的场景会比较多一些，比如像上面我们说的log,debounce等等，都一般会应用到类属性上面，接下来我们一起来具体看一下如何实现一个装饰器，并应用到类上面。在实现装饰器之前，我们需要先了解一下属性描述符\n\n了解一下属性描述符\n在我们定义一个对象里面的属性的时候，其实这个属性上面是有许多属性描述符的，这些描述符标明了这个属性能不能修改，能不能枚举，能不能删除等等，同时ECMAScript将这些属性描述符分为两类，分别是数据属性和访问器属性，并且数据属性与访问器属性是不能共存的。\n\n数据属性\n数据属性包含一个数据值的位置，在这个位置可以读取和写入值。数据属性包含了四个描述符，分别是\n\nconfigurable\n\n表示能不能通过delete删除属性，能否修改属性的其他描述符特性，或者能否将数据属性修改为访问器属性。当我们通过let obj = {name: ''}声明一个对象的时候，这个对象里面所有的属性的configurable描述符的值都是true\n\nenumerable\n\n表示能不能通过for in或者Object.keys等方式获取到属性，我们一般声明的对象里面这个描述符的值是true,但是对于class类里面的属性来说，这个值是false\n\nwritable\n\n表示能否修改属性的数据值，通过将这个修改为false,可以实现属性只读的效果。\n\nvalue\n\n表示当前属性的数据值，读取属性值的时候，从这里读取；写入属性值的时候，会写到这个位置。\n\n访问器属性\n访问器属性不包含数据值，他们包含了getter与setter两个函数，同时configurable与enumerable是数据属性与访问器属性共有的两个描述符。\n\ngetter\n\n在读取属性的时候调用这个函数，默认这个函数为undefined\n\nsetter\n\n在写入属性值的时候调用这个函数，默认这个函数为undefined\n\n了解了这六个描述符之后，你可能会有几个疑问：我如何去定义修改这些属性描述符？这些属性描述符与今天的文章主题有什么关系？接下来是揭晓答案的时候了。\n\n使用Object.defineProperty\n了解过vue2.0双向绑定原理的同学一定知道，Vue的双向绑定就是通过使用Object.defineProperty去定义数据属性的getter与setter方法来实现的，比如下面有一个对象\n\nlet obj = {\n  name: '子君',\n  officialAccounts: '前端有的玩'\n}\n我希望这个对象里面的用户名是不能被修改的，用Object.defineProperty该如何定义呢?\n\nObject.defineProperty(obj,'name', {\n  // 设置writable 是 false, 这个属性将不能被修改\n  writable: false\n})\n// 修改obj.name\nobj.name = \"君子\"\n// 打印依然是子君\nconsole.log(obj.name)\n通过Object.defineProperty可以去定义或者修改对象属性的属性描述符，但是因为数据属性与访问器属性是互斥的，所以一次只能修改其中的一类，这一点需要注意。\n\n定义一个防抖装饰器\n装饰器本质上依然是一个函数，不过这个函数的参数是固定的，如下是防抖装饰器的代码\n\n/**\n*@param wait 延迟时长\n*/\nfunction debounce(wait) {\n  return function(target, name, descriptor) {\n    descriptor.value = debounce(descriptor.value, wait)\n  }\n}\n// 使用方式\nclass MyClass {\n  @debounce(100)\n  follow() {\n    console.log('我是子君，我的公众号是 【前端有的玩】，关注有惊喜哦')\n  }\n}\n我们逐行去分析一下代码\n\n首先我们定义了一个 debounce函数，同时有一个参数wait，这个函数对应的就是在下面调用装饰器时使用的@debounce(100)\n\ndebounce函数返回了一个新的函数，这个函数即装饰器的核心，这个函数有三个参数，下面逐一分析\n\ntarget: 这个类属性函数是在谁上面挂载的，如上例对应的是MyClass类\n\nname: 这个类属性函数的名称，对应上面的follow\n\ndescriptor: 这个就是我们前面说的属性描述符，通过直接descriptor上面的属性，即可实现属性只读，数据重写等功能\n\n然后第三行 descriptor.value = debounce(descriptor.value, wait), 前面我们已经了解到,属性描述符上面的value对应的是这个属性的值，所以我们通过重写这个属性，将其用debounce函数包装起来，这样在函数调用follow时实际调用的是包装后的函数\n\n通过上面的三步，我们就实现了类属性上面可使用的装饰器，同时将其应用到了类属性上面\n\n在class上使用装饰器\n装饰器不仅可以应用到类属性上面，还可以直接应用到类上面，比如我希望可以实现一个类似Vue混入那样的功能，给一个类混入一些方法属性，应该如何去做呢?\n\n// 这个是要混入的对象\nconst methods = {\n  logger() {\n    console.log('记录日志')\n  }\n}\n \n// 这个是一个登陆登出类\nclass Login{\n  login() {}\n  logout() {}\n}\n如何将上面的methods混入到Login中，首先我们先实现一个类装饰器\n\nfunction mixins(obj) {\n  return function (target) {\n    Object.assign(target.prototype, obj)\n  }\n}\n \n// 然后通过装饰器混入\n@mixins(methods)\nclass Login{\n  login() {}\n  logout() {}\n}\n \n这样就实现了类装饰器。对于类装饰器，只有一个参数，即target,对应的就是这个类本身。\n\n了解完装饰器，我们接下来看一下如何在Vue中使用装饰器。\n\n在Vue中使用装饰器\n使用ts开发Vue的同学一定对vue-property-decorator不会感到陌生，这个插件提供了许多装饰器，方便大家开发的时候使用，当然本文的中点不是这个插件。其实如果我们的项目没有使用ts，也是可以使用装饰器的，怎么用呢？\n\n配置基础环境\n除了一些老的项目，我们现在一般新建Vue项目的时候，都会选择使用脚手架vue-cli3/4来新建，这时候新建的项目已经默认支持了装饰器，不需要再配置太多额外的东西，如果你的项目使用了eslint,那么需要给eslint配置以下内容。\n\n  parserOptions: {\n    ecmaFeatures:{\n      // 支持装饰器\n      legacyDecorators: true\n    }\n  }\n使用装饰器\n虽然Vue的组件，我们一般书写的时候export出去的是一个对象，但是这个并不影响我们直接在组件中使用装饰器，比如就拿上例中的log举例。\n\nfunction log() {\n  /**\n   * @param target 对应 methods 这个对象\n   * @param name 对应属性方法的名称\n   * @param descriptor 对应属性方法的修饰符\n   */\n  return function(target, name, descriptor) {\n    console.log(target, name, descriptor)\n    const fn = descriptor.value\n    descriptor.value = function(...rest) {\n      console.log(`这是调用方法【${name}】前打印的日志`)\n      fn.call(this, ...rest)\n      console.log(`这是调用方法【${name}】后打印的日志`)\n    }\n  }\n}\n \nexport default {\n  created() {\n    this.getData()\n  },\n  methods: {\n    @log()\n    getData() {\n      console.log('获取数据')\n    }\n  }\n}\n看了上面的代码，是不是发现在Vue中使用装饰器还是很简单的，和在class的属性上面使用的方式一模一样，但有一点需要注意，在methods里面的方法上面使用装饰器，这时候装饰器的target对应的是methods。\n\n除了在methods上面可以使用装饰器之外，你也可以在生命周期钩子函数上面使用装饰器，这时候target对应的是整个组件对象。\n\n一些常用的装饰器\n下面小编罗列了几个小编在项目中常用的几个装饰器，方便大家使用\n\n1. 函数节流与防抖\n函数节流与防抖应用场景是比较广的，一般使用时候会通过throttle或debounce方法对要调用的函数进行包装，现在就可以使用上文说的内容将这两个函数封装成装饰器， 防抖节流使用的是lodash提供的方法，大家也可以自行实现节流防抖函数哦\n\nimport { throttle, debounce } from 'lodash'\n/**\n * 函数节流装饰器\n * @param {number} wait 节流的毫秒\n * @param {Object} options 节流选项对象\n * [options.leading=true] (boolean): 指定调用在节流开始前。\n * [options.trailing=true] (boolean): 指定调用在节流结束后。\n */\nexport const throttle =  function(wait, options = {}) {\n  return function(target, name, descriptor) {\n    descriptor.value = throttle(descriptor.value, wait, options)\n  }\n}\n \n/**\n * 函数防抖装饰器\n * @param {number} wait 需要延迟的毫秒数。\n * @param {Object} options 选项对象\n * [options.leading=false] (boolean): 指定在延迟开始前调用。\n * [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n * [options.trailing=true] (boolean): 指定在延迟结束后调用。\n */\nexport const debounce = function(wait, options = {}) {\n  return function(target, name, descriptor) {\n    descriptor.value = debounce(descriptor.value, wait, options)\n  }\n}\n封装完之后，在组件中使用\n\nimport {debounce} from '@/decorator'\n \nexport default {\n  methods:{\n    @debounce(100)\n    resize(){}\n  }\n}\n2. loading\n在加载数据的时候，为了个用户一个友好的提示，同时防止用户继续操作，一般会在请求前显示一个loading,然后在请求结束之后关掉loading，一般写法如下\n\nexport default {\n  methods:{\n    async getData() {\n      const loading = Toast.loading()\n      try{\n        const data = await loadData()\n        // 其他操作\n      }catch(error){\n        // 异常处理\n        Toast.fail('加载失败');\n      }finally{\n        loading.clear()\n      }\n    }\n  }\n}\n我们可以把上面的loading的逻辑使用装饰器重新封装，如下代码\n\nimport { Toast } from 'vant'\n \n/**\n * loading 装饰器\n * @param {*} message 提示信息\n * @param {function} errorFn 异常处理逻辑\n */\nexport const loading =  function(message = '加载中...', errorFn = function() {}) {\n  return function(target, name, descriptor) {\n    const fn = descriptor.value\n    descriptor.value = async function(...rest) {\n      const loading = Toast.loading({\n        message: message,\n        forbidClick: true\n      })\n      try {\n        return await fn.call(this, ...rest)\n      } catch (error) {\n        // 在调用失败，且用户自定义失败的回调函数时，则执行\n        errorFn && errorFn.call(this, error, ...rest)\n        console.error(error)\n      } finally {\n        loading.clear()\n      }\n    }\n  }\n}\n \n然后改造上面的组件代码\n\nexport default {\n  methods:{\n    @loading('加载中')\n    async getData() {\n      try{\n        const data = await loadData()\n        // 其他操作\n      }catch(error){\n        // 异常处理\n        Toast.fail('加载失败');\n      }\n    }\n  }\n}\n3. 确认框\n当你点击删除按钮的时候，一般都需要弹出一个提示框让用户确认是否删除，这时候常规写法可能是这样的\n\nimport { Dialog } from 'vant'\n \nexport default {\n  methods: {\n    deleteData() {\n      Dialog.confirm({\n        title: '提示',\n        message: '确定要删除数据，此操作不可回退。'\n      }).then(() => {\n        console.log('在这里做删除操作')\n      })\n    }\n  }\n}\n我们可以把上面确认的过程提出来做成装饰器，如下代码\n\nimport { Dialog } from 'vant'\n \n/**\n * 确认提示框装饰器\n * @param {*} message 提示信息\n * @param {*} title 标题\n * @param {*} cancelFn 取消回调函数\n */\nexport function confirm(\n  message = '确定要删除数据，此操作不可回退。',\n  title = '提示',\n  cancelFn = function() {}\n) {\n  return function(target, name, descriptor) {\n    const originFn = descriptor.value\n    descriptor.value = async function(...rest) {\n      try {\n        await Dialog.confirm({\n          message,\n          title: title\n        })\n        originFn.apply(this, rest)\n      } catch (error) {\n        cancelFn && cancelFn(error)\n      }\n    }\n  }\n}\n然后再使用确认框的时候，就可以这样使用了\n\nexport default {\n  methods: {\n    // 可以不传参，使用默认参数\n    @confirm()\n    deleteData() {\n      console.log('在这里做删除操作')\n    }\n  }\n}\n是不是瞬间简单多了,当然还可以继续封装很多很多的装饰器，因为文章内容有限，暂时提供这三个。\n\n装饰器组合使用\n在上面我们将类属性上面使用装饰器的时候，说道装饰器可以组合使用，在Vue组件上面使用也是一样的，比如我们希望在确认删除之后，调用接口时候出现loading，就可以这样写(一定要注意顺序)\n\nexport default {\n  methods: {\n    @confirm()\n    @loading()\n    async deleteData() {\n      await  delete()\n    }\n  }\n}\n❝\n本节定义的装饰器，均已应用到这个项目中 https://github.com/snowzijun/vue-vant-base, 这是一个基于Vant开发的开箱即用移动端框架，你只需要fork下来，无需做任何配置就可以直接进行业务开发，欢迎使用，喜欢麻烦给一个star。\n\n❞ ❞\n---END---\n","description":"ref  :  https://blog.csdn.net/wk843620202/article/details/108162745\n"}]