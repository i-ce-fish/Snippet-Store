[{"key":"165e40d57cfcf546562c980bc45cafe83c16a023","createAt":1597287489932,"updateAt":1597287524126,"copy":0,"tags":["wx","js"],"name":"eventChannel 页面间通信","description":"","files":[{"key":"be2dbbbe6215c49139823e4258447c289b0a2e13","name":"发送页","value":"wx.navigateTo({\n                url: '/pages/shopping/order/item/index',\n                events: {\n                    // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据\n                    acceptDataFromOpenedPage: function (data) {\n                        console.log(data)\n                    },\n                    someEvent: function (data) {\n                        console.log(data)\n                    }\n                },\n                success: function (res) {\n                    // 通过eventChannel向被打开页面传送数据\n                    // 数组格式pro，统一格式\n                    // res.eventChannel.emit('orderItems', {data: 'test'})\n                    res.eventChannel.emit('acceptDataFromOpenerPage', {data: 'test'})\n                }\n            })"},{"key":"85aeeeb2807b5ca78c07e3ae1d0bb27f40e973f8","name":"接受页","value":"  onLoad: function (options) {\n            const eventChannel = this.getOpenerEventChannel()\n            // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据\n            eventChannel.on('orderItems', function (data) {\n                data.orderItems.forEach(item => {\n                    //todo get data from api\n                    console.log(item.productCode)\n                })\n            })\n        },"}]},{"key":"25dbe98dc7fc7a67729415ae69446b53eb95a18a","createAt":1597300434284,"updateAt":1597300434284,"copy":0,"tags":["wx","js"],"name":"page.filter代理page页面","lang":"JavaScript","value":"// utils/filter.js\nfunction loginCheck(pageObj) {\n    //for dev\n    // return pageObj;\n\n    if (pageObj.onLoad) {\n        let _onLoad = pageObj.onLoad;\n        // 使用onLoad的话需要传递options\n        pageObj.onLoad = function (options) {\n            if (wx.getStorageSync('token')) {\n                // 获取当前页面\n                let currentInstance = getPageInstance();\n                _onLoad.call(currentInstance, options);\n\n            } else {\n                //跳转到登录页\n               // getApp().$router.push('user/login/index')\n            }\n        }\n    }\n    return pageObj;\n}\n\n// 获取当前页面\nfunction getPageInstance() {\n    var pages = getCurrentPages();\n    return pages[pages.length - 1];\n}\n\nexports.loginCheck = loginCheck;\n","description":""},{"key":"99c9f7c923cf7f895ea44f97378b8129c6b0403c","createAt":1597300584255,"updateAt":1597300584255,"copy":0,"tags":["js"],"name":"防抖节流","lang":"JavaScript","value":"/*函数节流*/\nfunction throttle(fn, interval) {\n    var enterTime = 0;//触发的时间\n    var gapTime = interval || 300 ;//间隔时间，如果interval不传，则默认300ms\n    return function() {\n        var context = this;\n        var backTime = new Date();//第一次函数return即触发的时间\n        if (backTime - enterTime > gapTime) {\n            fn.call(context,arguments);\n            enterTime = backTime;//赋值给第一次触发的时间，这样就保存了第二次触发的时间\n        }\n    };\n}\n\n/*函数防抖*/\nfunction debounce(fn, interval) {\n    var timer;\n    var gapTime = interval || 1000;//间隔时间，如果interval不传，则默认1000ms\n    return function() {\n        clearTimeout(timer);\n        var context = this;\n        var args = arguments;//保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。\n        timer = setTimeout(function() {\n            fn.call(context,args);\n        }, gapTime);\n    };\n}\n\nexport default {\n    throttle,\n    debounce\n};\n","description":""},{"key":"303a2b473e4d16178daba13302d7e1474194b4e2","createAt":1597306238692,"updateAt":1597306259195,"copy":0,"tags":["js"],"name":"proxy代理拦截","description":"","files":[{"key":"1d11405255a62e9ae508b936460a0b6f61ddeb5b","name":"封装","value":"    proxy(fn) {\n        return new Proxy(fn, {\n            apply(target, ctx, args) {\n\n                console.log(`before:${target.name}`, args)\n                let result = Reflect.apply(...arguments);\n                console.log(`after:${target.name}`, result)\n\n                return result\n            }\n        })\n    },"},{"key":"27dcc053a463734fbc051271f1cc708ee86c4e89","name":"调用","value":" //局部拦截\n    test() {\n        proxy.login(this.sum)()\n    },\n    //整体拦截\n    test: proxy.login(function () {\n        this.add()\n    }),"}]},{"key":"34caa61f682bde4887940f5cd29b86be7d43e981","createAt":1597313447350,"updateAt":1597313447350,"copy":0,"tags":[],"name":"async 并发请求","lang":"JavaScript","value":" let articleList = await article.getList()\n let catalogList = await catalog.getList()\n\n await Promise.all([article.getList(), catalog.getList()])","description":"同步请求与并发请求"},{"key":"5f2ddedbe392a52f7dae290e8517cc34b06c44d1","createAt":1597321365662,"updateAt":1597321365662,"copy":0,"tags":["lodash"],"name":"lodash显式链式调用","lang":"JavaScript","value":"catalogList = _.chain(catalogList)\n            .forEach(o => {\n                o.list = _.filter(articleList, ['catalog_id', o.id])\n                o.head = _.filter(articleList, ['is_col_header', true])\n            })\n            .filter(o => {\n                return o.list.length > 0\n            })\n            .value();","description":""}]